from typing import Dict, List, Optional, Any


def _norm(s) -> str:
    if s is None:
        return ""
    return str(s).strip().lower()

def detect_header_row(path: str, expected_columns: List[str], max_rows: int = 35, max_cols: int = 80, sheet_name: Optional[str] = None) -> Optional[int]:
    import pandas as pd
    
    expected_norm = set([_norm(col) for col in expected_columns if _norm(col)])

    if not expected_norm:
        raise ValueError("No valid expected columns provided")
    
    # Read first max_rows with calamine (much faster than openpyxl cell iteration)
    df = pd.read_excel(
        path, 
        sheet_name=sheet_name or 0,
        header=None,
        nrows=max_rows,
        engine='calamine'
    )
    
    # Limit to max_cols
    if df.shape[1] > max_cols:
        df = df.iloc[:, :max_cols]
    
    best_row = None
    best_score = -1

    for r in range(len(df)):
        # Get all values in this row, normalize them
        values = [_norm(val) for val in df.iloc[r].values if pd.notna(val)]
        score = sum(1 for v in values if v in expected_norm)

        if score > best_score:
            best_score = score
            best_row = r + 1  # Convert to 1-based

    if best_score is None or best_score == 0:
        raise ValueError("No header row detected with the given expected columns")
    
    return best_row

def build_column_options(path: str, header_row: int, sheet_name: Optional[str] = None) -> List[str]:
    wb = openpyxl.load_workbook(path, read_only=True, data_only=True)
    ws = wb[sheet_name] if sheet_name and sheet_name in wb.sheetnames else wb[wb.sheetnames[0]]

    columns = []
    for c in range(1, 200):
        v = ws.cell(row=header_row, column=c).value
        if v is None:
            continue
        name = str(v).strip()
        if name and name not in columns:
            columns.append(name)
    
    return [{'label': col, 'value': col} for col in columns]
